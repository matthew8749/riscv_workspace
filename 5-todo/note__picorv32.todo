#How to Use PlainTasks:
∞♫♪ ▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸▸ ♪♫∞
♪♫♥♣♠☺√∞ ☺☺☺
💐💐💐💐💐💐💐💐💐💐💐💐

☺☺☺ "ctrl+enter" : adds a new task.
☺☺☺ "ctrl+i"     : also adds a new task
☺☺☺ "ctrl+d"     : marks a task as done
☺☺☺ "ctrl+d"     : again puts it back in pending mode
☺☺☺ "alt+c"      : marks the task as cancelled


☺☺☺ 產生統計：ctrl+shift+p 輸入Tasks: Copy Statistics 在文字中貼上即可顯示你的任務完成度
compile flow block digram:
  ┌────────────┐
  │  .c / .S   │
  └────┬───────┘
       ▼   (GCC 編譯)              .c / .S   → .o      使用 RISC-V 工具鏈編譯為目標檔
  ┌────────────┐
  │  .o + .lds │
  └────┬───────┘
       ▼   (GCC 連結)              .o + .lds → .elf    使用 linker 產生可執行檔                    |
  ┌──────────────┐
  │ firmware.elf │
  └────┬─────────┘
       ▼   (objcopy)
  ┌──────────────┐
  │ firmware.bin │
  └────┬─────────┘
       ▼   (makehex.py)
  ┌──────────────┐
  │ firmware.hex │
  └──────────────┘

| 步驟                    | 說明                                      |
| ---------------------- | -----------------------------------       |
| `.c`, `.S` → `.o`      | 使用 RISC-V 工具鏈編譯為目標檔               |
| `.o` + `.lds` → `.elf` | 使用 linker 產生可執行檔                    |
| `.elf` → `.bin`        | 移除 ELF headers，產出純 binary             |
| `.bin` → `.hex`        | 使用 `makehex.py` 產生 `$readmemh` 可用格式  |
| `make gen_fw`          | 一鍵完成以上所有步驟並產出 log                |

完整流程與相依關係圖:
  make gen_fw
    ↓
  make firmware/firmware.hex
    ↓
  firmware/makehex.py + firmware/firmware.bin
    ↓
  firmware/firmware.elf → objcopy → firmware.bin
    ↓
  firmware/start.o, *.o, tests/*.o + sections.lds → firmware.elf

下一步:
 ☐ 先搞懂他用的那些指令就好，先不要再管編譯流程。看指令是如何在verilog中執行
